# Executor Crate Design

## Overview

The executor crate implements a **Volcano-style iterator model** to execute physical plans generated by the planner. It bridges the planner's physical operators with the storage layer, buffer pool, WAL, and catalog to perform actual data reads, writes, and transformations.

## Role Within The Workspace

- **Input**: `PhysicalPlan` trees from `crates/planner` with resolved table IDs, column ordinals, and access methods
- **Output**: Streams of `Row` instances (from `crates/common`) representing query results
- **Dependencies**:
  - `planner` → physical plan definitions
  - `catalog` → table schemas and metadata
  - `storage` → heap file access via `HeapTable`
  - `buffer` → page cache via `Pager`
  - `wal` → durability for DML operations
  - `expr` → expression evaluation via `EvalContext`
  - `types` → scalar values and type system
  - `common` → rows, errors, config

## Core Abstractions

### Executor Trait (Volcano Model)

```rust
/// Iterator-style execution model where operators pull tuples from children
pub trait Executor {
    /// Initialize the operator (e.g., open cursors, allocate buffers)
    fn open(&mut self) -> DbResult<()>;

    /// Fetch the next row, or None if exhausted
    fn next(&mut self) -> DbResult<Option<Row>>;

    /// Release resources (close files, flush buffers)
    fn close(&mut self) -> DbResult<()>;

    /// Return the schema of rows produced by this operator
    fn schema(&self) -> &TableSchema;
}
```

### Execution Context

```rust
/// Shared state passed to all executors
pub struct ExecutionContext<'a> {
    pub catalog: &'a Catalog,
    pub pager: &'a mut Pager,
    pub wal: &'a mut Wal,
}

impl<'a> ExecutionContext<'a> {
    /// Get table metadata from catalog
    pub fn table(&self, table_id: TableId) -> DbResult<&TableMeta> { ... }

    /// Get heap table for data access
    pub fn heap_table(&mut self, table_id: TableId) -> DbResult<HeapTable> { ... }

    /// Log a DML operation to WAL
    pub fn log_dml(&mut self, record: WalRecord) -> DbResult<Lsn> { ... }
}
```

## Physical Operators (Priority Order)

### 1. SeqScanExec (Foundation)

**Purpose**: Scan all tuples in a heap table sequentially.

```rust
pub struct SeqScanExec {
    table_id: TableId,
    schema: TableSchema,
    heap_table: Option<HeapTable>, // Initialized in open()
    current_page: PageNumber,
    slot_iter: Option<SlotIterator>, // Iterator over slots in current page
}

impl Executor for SeqScanExec {
    fn open(&mut self) -> DbResult<()> {
        // Get HeapTable from context
        // Initialize to first page
    }

    fn next(&mut self) -> DbResult<Option<Row>> {
        loop {
            // Try next slot in current page
            if let Some(row) = self.slot_iter.next() {
                return Ok(Some(row));
            }
            // Move to next page, or return None if exhausted
            self.advance_page()?;
            if self.current_page >= self.heap_table.num_pages() {
                return Ok(None);
            }
        }
    }
}
```

**Integration**:
- Uses `HeapTable::get(page_num)` via `Pager` to load pages
- Deserializes slots into `Row` instances using schema
- Skips deleted slots (marked by storage layer)

### 2. FilterExec (Predicate Evaluation)

**Purpose**: Apply a WHERE predicate to rows from a child operator.

```rust
pub struct FilterExec {
    input: Box<dyn Executor>,
    predicate: ResolvedExpr, // From planner
    eval_ctx: EvalContext,   // Expression evaluator
}

impl Executor for FilterExec {
    fn next(&mut self) -> DbResult<Option<Row>> {
        loop {
            let row = match self.input.next()? {
                Some(r) => r,
                None => return Ok(None),
            };

            // Evaluate predicate with row context
            let result = self.eval_ctx.eval(&self.predicate, &row)?;

            // Return row if predicate is true
            if result.as_bool()? {
                return Ok(Some(row));
            }
        }
    }
}
```

**Integration**:
- Uses `expr::EvalContext` to evaluate `ResolvedExpr` predicates
- Passes `Row` as variable context for column references
- Handles NULL propagation and type coercion

### 3. ProjectExec (Column Selection)

**Purpose**: Select/reorder columns from input rows.

```rust
pub struct ProjectExec {
    input: Box<dyn Executor>,
    projections: Vec<ResolvedExpr>, // Column ordinals or expressions
    output_schema: TableSchema,
}

impl Executor for ProjectExec {
    fn next(&mut self) -> DbResult<Option<Row>> {
        let row = match self.input.next()? {
            Some(r) => r,
            None => return Ok(None),
        };

        // Evaluate each projection expression
        let projected_values: Vec<Value> = self.projections
            .iter()
            .map(|expr| self.eval_ctx.eval(expr, &row))
            .collect::<DbResult<_>>()?;

        Ok(Some(Row::new(projected_values)))
    }
}
```

**Integration**:
- Handles both simple column references and computed expressions
- Produces new schema with projected column names/types

### 4. InsertExec (Write Path)

**Purpose**: Insert new rows into a table with WAL logging.

```rust
pub struct InsertExec {
    table_id: TableId,
    schema: TableSchema,
    rows: Vec<Vec<Value>>, // Literal values from planner
}

impl Executor for InsertExec {
    fn open(&mut self) -> DbResult<()> {
        // Begin transaction (future: acquire locks)
        Ok(())
    }

    fn next(&mut self) -> DbResult<Option<Row>> {
        // INSERT is not a query, execute all and return count
        let mut count = 0;

        for value_list in &self.rows {
            let row = Row::new(value_list.clone());

            // 1. Log to WAL
            let wal_record = WalRecord::Insert {
                table_id: self.table_id,
                row: row.clone(),
            };
            self.ctx.log_dml(wal_record)?;

            // 2. Find page with space or allocate new page
            let page_num = self.find_page_with_space()?;

            // 3. Insert into heap file
            let heap_table = self.ctx.heap_table(self.table_id)?;
            heap_table.insert(page_num, &row)?;

            // 4. Mark page dirty in buffer pool
            self.ctx.pager.mark_dirty(page_num);

            count += 1;
        }

        // Return single row with count
        Ok(Some(Row::new(vec![Value::Int(count)])))
    }
}
```

**Integration**:
- WAL append → storage insert → buffer dirty marking
- Uses `HeapTable::insert()` to find free slot and serialize
- Future: check constraints, update indexes

### 5. UpdateExec (Modify Path)

**Purpose**: Update rows matching a predicate with WAL logging.

```rust
pub struct UpdateExec {
    input: Box<dyn Executor>, // Usually SeqScan + Filter
    assignments: Vec<(ColumnId, ResolvedExpr)>,
    table_id: TableId,
}

impl Executor for UpdateExec {
    fn next(&mut self) -> DbResult<Option<Row>> {
        let mut count = 0;

        while let Some(old_row) = self.input.next()? {
            // 1. Compute new row by applying assignments
            let new_row = self.apply_assignments(&old_row)?;

            // 2. Log to WAL
            let wal_record = WalRecord::Update {
                table_id: self.table_id,
                old_row: old_row.clone(),
                new_row: new_row.clone(),
            };
            self.ctx.log_dml(wal_record)?;

            // 3. Update in-place (or delete + insert if size changes)
            let (page_num, slot_num) = old_row.physical_location()?;
            let heap_table = self.ctx.heap_table(self.table_id)?;
            heap_table.update(page_num, slot_num, &new_row)?;

            // 4. Mark page dirty
            self.ctx.pager.mark_dirty(page_num);

            count += 1;
        }

        Ok(Some(Row::new(vec![Value::Int(count)])))
    }
}
```

**Integration**:
- Combines scan operator with per-row updates
- Handles variable-length updates (may require delete + reinsert)

### 6. DeleteExec (Remove Path)

**Purpose**: Delete rows matching a predicate with WAL logging.

```rust
pub struct DeleteExec {
    input: Box<dyn Executor>, // Usually SeqScan + Filter
    table_id: TableId,
}

impl Executor for DeleteExec {
    fn next(&mut self) -> DbResult<Option<Row>> {
        let mut count = 0;

        while let Some(row) = self.input.next()? {
            // 1. Log to WAL
            let wal_record = WalRecord::Delete {
                table_id: self.table_id,
                row: row.clone(),
            };
            self.ctx.log_dml(wal_record)?;

            // 2. Mark slot as deleted in heap file
            let (page_num, slot_num) = row.physical_location()?;
            let heap_table = self.ctx.heap_table(self.table_id)?;
            heap_table.delete(page_num, slot_num)?;

            // 3. Mark page dirty
            self.ctx.pager.mark_dirty(page_num);

            count += 1;
        }

        Ok(Some(Row::new(vec![Value::Int(count)])))
    }
}
```

### 7. IndexScanExec (Future Optimization)

**Purpose**: Use B+Tree index to find rows matching equality/range predicates.

```rust
pub struct IndexScanExec {
    table_id: TableId,
    index_name: String,
    predicate: IndexPredicate, // Eq(Value) or Range(min, max)
    schema: TableSchema,
}

impl Executor for IndexScanExec {
    fn next(&mut self) -> DbResult<Option<Row>> {
        // 1. Search B+Tree for matching keys
        // 2. Retrieve RID (page_num, slot_num) from leaf
        // 3. Fetch actual row from heap file
        // 4. Return row
    }
}
```

**Integration**:
- Future: requires `index/` crate with B+Tree implementation
- Planner selects this operator when predicate matches indexed column

## Execution Pipeline

### Query Execution Flow

```rust
pub fn execute_query(
    plan: PhysicalPlan,
    ctx: &mut ExecutionContext,
) -> DbResult<Vec<Row>> {
    // 1. Build operator tree from physical plan
    let mut executor = build_executor(plan, ctx)?;

    // 2. Open resources
    executor.open()?;

    // 3. Pull rows until exhausted
    let mut results = Vec::new();
    while let Some(row) = executor.next()? {
        results.push(row);
    }

    // 4. Clean up
    executor.close()?;

    Ok(results)
}

fn build_executor(
    plan: PhysicalPlan,
    ctx: &ExecutionContext,
) -> DbResult<Box<dyn Executor>> {
    match plan {
        PhysicalPlan::SeqScan { table_id, schema } => {
            Ok(Box::new(SeqScanExec::new(table_id, schema)))
        }
        PhysicalPlan::Filter { input, predicate } => {
            let child = build_executor(*input, ctx)?;
            Ok(Box::new(FilterExec::new(child, predicate)))
        }
        PhysicalPlan::Project { input, projections, schema } => {
            let child = build_executor(*input, ctx)?;
            Ok(Box::new(ProjectExec::new(child, projections, schema)))
        }
        // ... other operators
    }
}
```

### DML Execution Flow

```rust
pub fn execute_dml(
    plan: PhysicalPlan,
    ctx: &mut ExecutionContext,
) -> DbResult<u64> {
    let mut executor = build_executor(plan, ctx)?;
    executor.open()?;

    // DML returns single row with affected count
    let result = executor.next()?
        .ok_or_else(|| DbError::Executor("DML returned no rows".into()))?;

    executor.close()?;

    // Extract count from result row
    Ok(result.get(0)?.as_int()?)
}
```

## Integration Points

### Storage Layer Integration

```rust
// Executor needs HeapTable to read/write pages
pub trait StorageProvider {
    fn heap_table(&mut self, table_id: TableId) -> DbResult<HeapTable>;
}

impl StorageProvider for ExecutionContext<'_> {
    fn heap_table(&mut self, table_id: TableId) -> DbResult<HeapTable> {
        let table_meta = self.catalog.table(table_id)?;
        let file_path = self.data_dir.join(format!("{}.heap", table_meta.name));
        HeapTable::open(file_path, self.pager)
    }
}
```

### WAL Integration

```rust
// DML operators log before applying changes
impl ExecutionContext<'_> {
    pub fn log_dml(&mut self, record: WalRecord) -> DbResult<Lsn> {
        // 1. Serialize record
        let bytes = record.serialize()?;

        // 2. Append to WAL
        let lsn = self.wal.append(&bytes)?;

        // 3. Future: fsync periodically or on commit
        // self.wal.sync()?;

        Ok(lsn)
    }
}
```

### Expression Evaluation Integration

```rust
// FilterExec and ProjectExec need expression evaluator
impl FilterExec {
    fn eval_predicate(&mut self, row: &Row) -> DbResult<bool> {
        // Create evaluation context with row values
        let mut ctx = EvalContext::new();

        // Bind column references to row values
        for (col_id, value) in row.iter().enumerate() {
            ctx.bind_variable(col_id, value.clone());
        }

        // Evaluate resolved expression
        let result = ctx.eval(&self.predicate)?;

        // Convert to boolean (NULL → false in SQL semantics)
        Ok(result.as_bool().unwrap_or(false))
    }
}
```

## Error Handling

```rust
// Add Executor variant to DbError
#[derive(Debug, thiserror::Error)]
pub enum DbError {
    #[error("Executor error: {0}")]
    Executor(String),
    // ... existing variants
}
```

**Error scenarios:**
- **SeqScan**: Page read failure, deserialization error
- **Filter**: Predicate evaluation type error (e.g., comparing INT to TEXT)
- **Insert**: No free space, constraint violation (future)
- **Update/Delete**: Row not found (if MVCC), concurrency conflict (future)

## Testing Strategy

### Unit Tests (Per Operator)

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn seq_scan_reads_all_rows() {
        // Create in-memory heap table with known rows
        // Build SeqScanExec
        // Verify all rows returned in order
    }

    #[test]
    fn filter_applies_predicate() {
        // Create mock input executor returning 10 rows
        // Build FilterExec with "age > 30"
        // Verify only matching rows returned
    }

    #[test]
    fn insert_logs_and_persists() {
        // Build InsertExec with test row
        // Execute and verify WAL record written
        // Verify row exists in heap file
    }
}
```

### Integration Tests

```rust
#[test]
fn end_to_end_select_with_filter() {
    // 1. Create catalog with "users" table
    // 2. Insert test data via InsertExec
    // 3. Build plan: SeqScan → Filter(age > 30) → Project(name)
    // 4. Execute and verify results
}

#[test]
fn update_persists_across_restart() {
    // 1. Insert rows
    // 2. Update via UpdateExec
    // 3. Simulate crash (close all handles)
    // 4. Replay WAL and reopen
    // 5. Verify updated values present
}
```

### Property Tests

```rust
#[proptest]
fn filter_never_returns_non_matching_rows(
    rows: Vec<Row>,
    predicate: ResolvedExpr,
) {
    // Build FilterExec with predicate
    // Feed rows through executor
    // Verify all returned rows satisfy predicate
}
```

## Build & Validation

```bash
cargo check -p executor              # Fast validation
cargo test -p executor                # Unit tests
cargo test --test integration         # End-to-end tests
cargo llvm-cov --package executor --html  # Coverage report (target 90%+)
```

## Module Layout

```
crates/executor/
├── Cargo.toml
├── CLAUDE.md              # Implementation guidelines
├── DESIGN.md              # This document
├── src/
│   ├── lib.rs             # ExecutionContext, execute_query/execute_dml
│   ├── trait.rs           # Executor trait
│   ├── scan.rs            # SeqScanExec, IndexScanExec
│   ├── filter.rs          # FilterExec
│   ├── project.rs         # ProjectExec
│   ├── dml.rs             # InsertExec, UpdateExec, DeleteExec
│   ├── builder.rs         # build_executor() factory
│   └── tests.rs           # Unit tests
└── tests/
    └── integration.rs     # End-to-end execution tests
```

## Dependencies

```toml
[dependencies]
common = { workspace = true }
types = { workspace = true }
expr = { workspace = true }
parser = { workspace = true }
planner = { workspace = true }
catalog = { workspace = true }
storage = { workspace = true }
buffer = { workspace = true }
wal = { workspace = true }
hashbrown = { workspace = true }

[dev-dependencies]
proptest = { workspace = true }
tempfile = { workspace = true }
```

## Future Extensions

### Concurrency Control
- Add `LockManager` to `ExecutionContext`
- Acquire read/write locks in `open()`
- Release in `close()`

### Transactions
- Begin/Commit/Rollback operators
- Group WAL records by transaction ID
- Atomic batch apply on commit

### Advanced Operators
- **HashJoinExec**: Build hash table from left, probe with right
- **MergeJoinExec**: Assume sorted inputs, merge in one pass
- **SortExec**: External sort for ORDER BY
- **AggregateExec**: Hash-based aggregation for GROUP BY

### Performance Optimizations
- **Vectorization**: Process rows in batches (like Arrow RecordBatch)
- **Parallel Execution**: Split scans across threads
- **Compiled Expressions**: JIT compile predicates for hot paths

## Success Criteria

✅ **Phase 1 (MVP)**:
- SeqScan + Filter + Project work end-to-end
- Insert + WAL logging persists data
- All operators tested with 90%+ coverage

✅ **Phase 2 (DML)**:
- Update/Delete with WAL integration
- Recovery test: insert → crash → replay → verify

✅ **Phase 3 (Optimization)**:
- IndexScan operator uses B+Tree (requires index crate)
- Planner selects best access method

## Open Questions

1. **Row Physical Location**: How should `Row` track `(page_num, slot_num)` for updates?
   - Option A: Add `RID` field to `Row` struct
   - Option B: Return tuple `(Row, RID)` from `next()`
   - **Recommendation**: Option B for clean separation

2. **Transaction Context**: Should `ExecutionContext` own a transaction ID?
   - Not needed for v1 (implicit single-statement transactions)
   - Add `txn_id: Option<TxnId>` field for future multi-statement support

3. **Constraint Checking**: Where should primary key/unique checks happen?
   - InsertExec: Check before WAL log or after?
   - **Recommendation**: Check before logging to avoid rolling back

4. **Type Coercion**: Should executor handle implicit casts (e.g., INT to REAL)?
   - Delegate to `expr::EvalContext` for consistency
   - Planner should insert explicit cast nodes for clarity

## Summary

The executor crate ties together all prior work:
- Consumes **planner** physical plans with resolved IDs
- Reads/writes via **storage** heap files and **buffer** pool
- Ensures durability via **wal** logging
- Evaluates predicates with **expr** evaluator
- Uses **catalog** schemas and **types** values

This design prioritizes:
1. **Correctness**: WAL-first writes, consistent operator semantics
2. **Testability**: Small operators with clear contracts
3. **Extensibility**: Trait-based design for future operators (joins, sorts)
4. **Integration**: Minimal changes to existing crates

Next step: Create `crates/executor/CLAUDE.md` with implementation guidelines following project patterns.
